user: luyota
user: pcish

Table of Contents
----
I. New in Assignment 3
  1. New Features
    A. Exceptions and Logging
    B. ActivityManager
      a. Virtual Time
      b. Real Time
    C. Shipment Transfers
      a. Mechanics
      b. Statistics Collected
      c. Routing Algorithms
    D. Scheduled Changes to Fleet Attributes 
  2. Simulations
    A. verification.cpp
    B. experiment.cpp
  3. Summary of Rep Layer Interface Changes
II. Original Assignment 2 README
----
I. New in Assignment 3
  1. New Features
    A. Exceptions and Logging
        Our logging system is implemented pretty much as the textbook does. We have an abstract base class Log with the method entryNew which should be inherited by its subclasses to record the logging message. The class Log's subclass, CerrLog, overrides this method and output the logging message into standard error. Programmers are free to create any subclasses of Log that stores the logging message into different places. 
        The logging messages are categorized into 6 different types based on their priority. For example, debugging info will be categorized as Debug. In addition, we provide a set of macros (such as LOG_DEBUG(f, x) ) to facilitate the usage of the logging system.
        Exceptions are utilized in this project. We use exceptions from the classes of fwk/Exceptions.h. These include:
        Fwk::RangeException - used to indicate out of range exception for value types, such as Mile, Hour, etc.
        Fwk::NameInUseException - since the whole system supports naming and names are important to access instances of classes, names of different instances shouldn't be the same, and when this occurs, Fwk::NameInUseException will be thrown.
        Fwk:UnknownArgException - thrown when the commands for the rep layer from client code are unknown.
        Fwk::EntityNotFoundException - thrown when an instance of the rep layer is not found when requested by name.
        Fwk::InternalException - thrown when the path returned by the routing function is invalid.
        
    B. ActivityManager 
     a. Virtual Time
        An activity is associated with a time, indicating when it should be executed in virtual time. When an activity registers to the activity manager, the activity manager puts it to a priority queue sorted by the time it associates with. Then, when the simulation starts, the activity manager pops the queue to get the activity with the earliest time, executes it, and repeats these two steps until the time of the next activity is later than the time the client wants the simulation to stops.
        There is a special case to deal with. When an activity is waiting in activity manager's queue but has already been marked as deleted (by setting its status), the activity manager has to skip that activiy by simply popping it out so that it won't process an activity that shouldn't be executed.
     b. Real Time
        To make the simulation use real time, the activity manager executes normally as the virtual time do except that when it pops out an activity, it sleeps for some time (the difference between now and the time of the activity) before execution. To specify this behavior, the cliend should call::
        activityManager->timeSteppingIs(Activity::Manager::realtime()); 
        To change back to virtual time, call
        activityManager->timeSteppingIs(Activity::Manager::virtualtime()); 


    C. Shipment Transfers
     a. Mechanics
        The sequence of actions for shipment transfers occur as follows. 

        Each Customer location has the following three 'source attributes': 'destination", "transfer rate" and "shipment size". 
        
        As soon as all three 'source attributes' have valid values, "transfer rate" shipments are created at the Customer location and every 24 hours starting from the current time another "transfer rate" shipments will be created. As soon as a shipment is created, it begins to move through the network. 
        
        A shipment moves through the network by calling the (current) routing algorithm to obtain the 'next segment' (and therefore the 'next location') that the shipment should travel to. The shipment then makes a 'request for transfer' to the 'next segment'. As a part of granting a 'request for transfer', a segment must decrement its 'available capacity' by 1. If the request is granted, the transfer is 'initiated' and the shipment will arrive at the 'next location' after an amount of hours (rounded up to the nearest integer) determined by the fleet speed, segment length, fleet capacity and shipment size. Throughout the transfer, the shipment is still considered to be at the originating location -- only after the transfer is complete is the shipment considered to be at the 'next location'. 
        
        After arriving at the 'next location', the shipment checks whether this is the intended destination of the shipment. If it is the intended destination, the shipment is 'delivered'. If it is not the intended destination, the shipment repeats the process of the previous paragraph.
     b. Statistics Collected
        Various statistics about shipments are collected at Customer locations and at Segments.
        The following attributes can be read from Customer locations:
     	    "shipments received": the number of shipments received (i.e. delivered to) the customer location
     	    "average latency": the average time it took a shipment to be delivered to the customer location (i.e. the average of the difference between the time the shipment was created and the time the shipment was received)
     	    "total cost": the sum of all the transit costs of shipments received by the customer, where the transit cost of a shipment is the sum of the costs of all segments that the shipment was transported over on its way from the source customer to the destination customer.
     	 And the following aggregate Segment data attributes can be read from the Stats instance:
     	     "shipments received by segments": the sum of all shipments transfers 'initiated' (i.e. does not have to have been completed) across all segments in the network (at the time of the query)
     	     "shipments refused by segments": the sum across all segments in the network (at the time of the query) of all 'requests for transfer' that could not be satisfied (e.g. due to insufficient capacity at the time the request was made)
     	     "average shipments received by segments": the value of "shipments received by segments" divided by the number of segments in the network (at the time of the query)
     	     "average shipments refused by segments": the value of "shipments refused by segments" divided by the number of segments in the network (at the time of the query)
     c. Routing Algorithms
        We implemented three routing algorithms: Bfs, Dijkstra's shortest path, and Random Walk (used primarily for testing). We decouple the routing algorithm from the Shipping Network by providing a base class for all routing algorithms and three subclasses (Bfs, Dijkstra and RandomWalk) that overrides the routing behavior of the base class. 
        i. In Bfs, it finds the path that passes through the least number of Segments (and also Locations) by spanning the path out from the source. 
        ii. In Dijkstra, it uses the lengths of the Segments as the distance metric. For each iteration, it finds the nearest Location X to the source currently and updates all that Location's neighboring Locations to be the minimum between those Locations' distance from the origin and the distance X from the origin plus the length of the segment between X and this Location.
        iii. In RandomWalk, the next location to travel to is randomly picked from all locations connected to the current location.

    D. Scheduled Changes to Fleet Attributes
        We associate Fleet with time. Fleet may have different cost/speed/capacity at different hours. To use scheduled changes feature, client should call 
        fleetRep->attributeIs("FleetType, attribute from x to y", "value"); whereas FleetType is one of Truck/Plane/Boat, attribute is either cost/speed/capacity, x is the start time and y is the end time for this scheduled changes. The attribute of the Fleet engine between time x and y is changed to the new value. Thus, during simulation, when time steps forward, Fleet returns the attribute value at that time.
        

  2. Simulations
    A. verification.cpp
        Network graph:
     0 --- 1
   /  \   / \
 /      8     \
7              2
|              |
|       9      |
6              3
 \            /
   \        /
     5 --- 4

        Verification runs three rounds of tests of sending shipments from location 0 to 1, and each round lasts for 24 hours. Thus, their virtual time period of simulation are 0 to 23, 24 to 47, and 48 to 71. The shipment size is set to 100, and the transfer rate is 10. In the first round, it uses dijkstra's shortest path algorithm to plan routes. In the second round, it shrinks the capacity of segment between location 0 and 1 to be half, also using dijkstra's algorithm. In the final round, it changes its routing algorithm to random walk with capacity being the same as the second round. The following shows the results:

        [Round 1]
         After 24 hours with plane fleet capacity = 100:
         Shipments received at destination: 10
         Average latency of received shipments: 5.7
         Average shipments refused by segments: 2.35
         Total cost of received shipments: 10
         ----
         [Round 2]
         After another 24 hours with plane fleet capacity = 50:
         Shipments received at destination: 20
         Average latency of received shipments: 8.35
         Average shipments refused by segments: 6.85
         Total cost of received shipments: 20
         ----
         [Round 3]
         After another 24 hours using routing = randomwalk:
         Shipments received at destination: 28
         Average latency of received shipments: 8.39286
         Average shipments refused by segments: 7.85
         Total cost of received shipments: 76
         ----

         Comparing Round 1 and Round 2, since they both use dijkstra's algorithm, the path is both from location 0 to 1 directly. However, the capacity of the segemnt between location 0 and 1 is halved in the second round, Round 2 takes longer time to send all the shipments to location 1 (average latencies are 5.7 vs 8.35), the congestion situation is more severe (average shipments refused are 2.35 vs 6.85). Also, because they travel along the same path, their costs are the same (10).

         Note that the values 8.35 and 6.85 are averaged for the shipments from both Round 1 and 2. That is, if we only consider the shipments for Round 2, the actual values will be higher.

         Then we compare Round 2 and Round 3. Round 3 applies random walk algorithm, and thus the latency, refused shipments and costs are all higher than Round 2. Moreover, something worth noticing is that not all shipments made it to reach their destination (only 9, not 10) in 24 hours in Round 3. That is because with random walk algorithm the shipments may head for the wrong directions or wander around some locations.

         Besides statistics, Round 3 also demonstrates our realtime activity manager.


    B. experiment.cpp
         Based on the requirements of the project, we ran experiment and got the following results:

         Simulation 1: all sources send 100 packages
         Shipments received at destination: 100
         Average latency of received shipments: 7.5
         Average shipments received by segments: 1.35135
         Average shipments refused by segments: 2.02703
         Total cost of received shipments: 300
         ========================================
         Simulation 2: all sources send rand(1, 1000) packages
         Shipments received at destination: 49
         Average latency of received shipments: 10.1837
         Average shipments received by segments: 1.16667
         Average shipments refused by segments: 1.96847
         Total cost of received shipments: 147

         First, we notice that shipments received at destination in simulation 2 is fewer than in simulation 1. That is due to the unbalanced flow of traffic in simulation 2 that some terminals are bottlenecks while some terminals don't have heavy traffic. In simulation 2, the expected value of the number of packages generating by each source is 500, which is more than simulation 1 does; however, only 49 are received at destination. Thus we can see that this unbalanced flow of traffic can result in significant decrease in the performance.

         In addition, the latency in simulation 2 is also higher than in simulation 1. That is also due to unbalanced traffic flow. In simulation 1, the latency is amortized by the higher throughput of the shipments, while in simulation 2, shipments may be stuck at some bottleneck terminals and thus have to wait longer to be sent than in the case when all terminals receive and send the same number of shipments.

  3. Summary of Rep Layer Interface Changes
    StatsRep
    New attributes:
        shipments received by segments
        shipments refused by segments
        average shipments received by segments
        average shipments refused by segments
    
    ConnRep
    New attribute: routing   value: [Dijkstra | BFS | Random Walk]

    FleetRep
    transportationType, property from x to y
    transportationType: [Truck | Plane | Boat]
    property: [cost | speed | capacity]
    
    Customer"


II. Original Assignment 2 README

Submission Notes for TA:
All our test cases are under the directory: 
testcases/simple

In this assignment our design has 3 layers: the Engine Layer, the Representation Layer and the Client layer, as required by the assignment description. The execution flow is: the Client Layer sends string commands to the Representation Layer in order to execute tasks, then the Representation Layer translates these string commands into corresponding calls on the Engine Layer interface, which includes creating/deleting objects in the Engine Layer as well as setting/reading the attributes of these objects.

The following explains our design of the Engine Layer and the Representation Layer.

The Engine Layer
    The Engine Layer represents the real world objects (entities) using the following classes:
- Location (subclases: Customer, Port, and Terminal)
- Segment
- Fleet(subclasses: Truck Fleet/Boat Fleet/Plane Fleet)
    The Engine Layer also has a ShippingNetwork class that keeps track of the shipping network settings and an EngineManager class that acts as the factory for the above entities.

1. Transportation Method
    This system has to support three kinds of transportation types. In our design, we provide a enumeration type that encodes this information in Segment, which is Segment::TransportationMode. Entities such as Segment and Terminal then use this type to indicate their own transportation mode. 

2. Location, Customer, Port, and Terminal
    Since Customer, Port, and Terminal are three kinds of different Locations, the base class Location is shared amongst them. Besides the general interface provided by Location, such as adding new segments to a Location, Customer, Port, and Terminal have their own notifiee interfaces. When one of these objects is destoyed, it notifies its notifiee (reactor) about its deletion. In our design, the reactor then updates the number of instances of this class in the ShippingNetwork. This is how we update the statistics.
 
3. Segment
    Besides keeping its own attributes, a Segment object is also used by Location to determine if its connecting segments follow the restrictions applied on the Location. For example, a Terminal object can only connect to Segments with the same transportation mode. In addition, similar to Location, Segment¡¦s reactors are used to update the statistics.

4. EngineManager
    EngineManager is the factory for instantiating the entities objects. Also, since all entities are instantiated from here, it notifies its reactor about the instantiation so that the reactor can update the statistics.

5.  ShippingNetwork
    ShippingNetwork records the system wide information, including statistics as well as the paths between different nodes under some restrictions, which matches to the Stats and Conn requirement.

6. Fleet, TruckFleet, PlaneFleet, and BoatFleet
    Since Fleet is used to store the system wide settings for 3 different kinds of transportation modes and should be a singleton, we use the subclasses of TruckFleet, PlaneFleet and BoatFleet which are all singletons for this purpose instead of using Segment::TransportationMode in a single Fleet  class to avoid the possible misunderstanding about whether the Fleet class is a singleton or not.

The Representation Layer
    The Representation Layer acts as an intermediate layer that interprets the message from the client as a series of actions performed on the Engine Layer and also translates the attributes in the Engine Layer into string format and passes them back to the client. Different requirements in the system have their corresponding classes in this layer, such as SegmentRep, ConnRep. Moreover, almost every Rep object has a corresponding Engine object to perform its logic operations. The only 2 exceptions are ConnRep and StatsRep, which utilize ShippingNetwork to get the information they need.
    Like the Engine Layer, the instances in the Representation Layer are managed by the manager, ManagerImp that is in charge of new/delete and indexing other Rep objects. The reason that every Rep classes are subclasses of Instance is because in that way their instances can be easily indexed and managed by ManagerImp.

Issues:
1. Dealing with Connectivity
    When deciding the data structure for storing and passing the path for exploring or connectivity in the Engine Layer, we discussed several options. The accessor for this path attribute could either return a path tree or a path of a given index. However, we considered the path tree a bad solution in that in the logical aspect it is actually returning a collection of paths. Instead, we believe a better solution is to call the path function with an index k as its parameter, and it returns a single path which is the k-th path in the path collection. In this case, the client code could manipulate these paths such as making comparisons (although not required in this assignment) without having to deal with the path tree by itself.

2. Using of smart pointer:
    While implementing the Notifier and Notifiee design, we discovered that we needed a pointer to the notifier in the notifiee, yet the pointer must not contribute to the reference count or else the notifier will never be deleted. To solve this, we created a WeakPtr class corresponding to the weak reference concept discussed in the textbook. Ideally WeakPtr should be a superclass of Ptr, but being unsure whether Ptr can be modified we simply kept them as two unrelated classes.
