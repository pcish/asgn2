user: luyota
user: pcish

Table of Contents
----
I. New in Assignment 3
  1. New Features
    A. Exceptions and Logging
    B. ActivityManager
      a. Virtual Time
      b. Real Time
    C. Shipment Transfers
      a. Mechanics
      b. Statistics Collected
      c. Routing Algorithms
    D. Scheduled Changes to Fleet Attributes 
  2. Simulations
    A. verification.cpp
    B. experiment.cpp
  3. Summary of Rep Layer Interface Changes
II. Original Assignment 2 README
----
I. New in Assignment 3
  1. New Features
    A. Exceptions and Logging
        Our logging system is implemented pretty much as the textbook does. We have an abstract base class Log with the method entryNew which should be inherited by its subclasses to record the logging message. The class Log's subclass, CerrLog, overrides this method and output the logging message into standard error. Programmers are free to create any subclasses of Log that stores the logging message into different places. 
        The logging messages are categorized into 6 different types based on their priority. For example, debugging info will be categorized as Debug. In addition, we provide a set of macros (such as LOG_DEBUG(f, x) ) to facilitate the usage of the logging system.
        Exceptions are utilized in this project. We use exceptions from the classes of fwk/Exceptions.h. These include:
        Fwk::RangeException - used to indicate out of range exception for value types, such as Mile, Hour, etc.
        Fwk::NameInUseException - since the whole system supports naming and names are important to access instances of classes, names of different instances shouldn't be the same, and when this occurs, Fwk::NameInUseException will be thrown.
        Fwk:UnknownArgException - thrown when the commands for the rep layer from client code are unknown.
        Fwk::EntityNotFoundException - thrown when an instance of the rep layer is not found when requested by name.
        Fwk::InternalException - thrown when the path returned by the routing function is invalid.
        
    B. ActivityManager 
     a. Virtual Time
        An activity is associated with a time, indicating when it should be executed in virtual time. When an activity registers to the activity manager, the activity manager puts it to a priority queue sorted by the time it associates with. Then, when the simulation starts, the activity manager pops the queue to get the activity with the earliest time, executes it, and repeats these two steps until the time of the next activity is later than the time the client wants the simulation to stops.
        There is a special case to deal with. When an activity is waiting in activity manager's queue but has already been marked as deleted (by setting its status), the activity manager has to skip that activiy by simply popping it out so that it won't process an activity that shouldn't be executed.
     b. Real Time
        To make the simulation use real time, the activity manager executes normally as the virtual time do except that when it pops out an activity, it sleeps for some time (the difference between now and the time of the activity) before execution.

    C. Shipment Transfers
     a. Mechanics
        The sequence of actions for shipment transfers occur as follows. 
        Each Customer location has the following three 'source attributes': 'destination", "transfer rate" and "shipment size". As soon as all three 'source attributes' have valid values, "transfer rate" shipments are created at the Customer location and every 24 hours starting from the current time another "transfer rate" shipments will be created. As soon as a shipment is created, it begins to move through the network. A shipment moves through the network by calling the (current) routing algorithm to obtain the 'next segment' (and therefore the 'next location') that the shipment should travel to. The shipment then makes a 'request for transfer' to the 'next segment'. As a part of granting a 'request for transfer', a segment must decrement its 'available capacity' by 1. If the request is granted, the transfer is 'initiated' and the shipment will arrive at the 'next location' after an amount of hours determined by the fleet speed, segment length, fleet capacity and shipment size. Throughout the transfer, the shipment is still considered to be at the originating location -- only after the transfer is complete is the shipment considered to be at the 'next location'.
     b. Statistics Collected
        Various statistics about shipments are collected at Customer locations and at Segments.
        The following attributes can be read from Customer locations:
     	    "shipments received": the number of shipments received (i.e. delivered to) the customer location
     	    "average latency": the average time it took a shipment to be delivered to the customer location (i.e. the average of the difference between the time the shipment was created and the time the shipment was received)
     	    "total cost": the sum of all the transit costs of shipments received by the customer, where the transit cost of a shipment is the sum of the costs of all segments that the shipment was transported over on its way from the source customer to the destination customer.
     	 And the following aggregate Segment data attributes can be read from the Stats instance:
     	     "shipments received by segments": the sum of all shipments transfers 'initiated' (i.e. does not have to have been completed) across all segments in the network (at the time of the query)
     	     "shipments refused by segments": the sum across all segments in the network (at the time of the query) of all 'requests for transfer' that could not be satisfied (e.g. due to insufficient capacity at the time the request was made)
     	     "average shipments received by segments": the value of "shipments received by segments" divided by the number of segments in the network (at the time of the query)
     	     "average shipments refused by segments": the value of "shipments refused by segments" divided by the number of segments in the network (at the time of the query)
     c. Routing Algorithms

    D. Scheduled Changes to Fleet Attributes

  2. Simulations
    A. verification.cpp
    B. experiment.cpp
  3. Summary of Rep Layer Interface Changes
==
To be tested:
Activity manager realtime
==


II. Original Assignment 2 README

Submission Notes for TA:
All our test cases are under the directory: 
testcases/simple

In this assignment our design has 3 layers: the Engine Layer, the Representation Layer and the Client layer, as required by the assignment description. The execution flow is: the Client Layer sends string commands to the Representation Layer in order to execute tasks, then the Representation Layer translates these string commands into corresponding calls on the Engine Layer interface, which includes creating/deleting objects in the Engine Layer as well as setting/reading the attributes of these objects.

The following explains our design of the Engine Layer and the Representation Layer.

The Engine Layer
    The Engine Layer represents the real world objects (entities) using the following classes:
- Location (subclases: Customer, Port, and Terminal)
- Segment
- Fleet(subclasses: Truck Fleet/Boat Fleet/Plane Fleet)
    The Engine Layer also has a ShippingNetwork class that keeps track of the shipping network settings and an EngineManager class that acts as the factory for the above entities.

1. Transportation Method
    This system has to support three kinds of transportation types. In our design, we provide a enumeration type that encodes this information in Segment, which is Segment::TransportationMode. Entities such as Segment and Terminal then use this type to indicate their own transportation mode. 

2. Location, Customer, Port, and Terminal
    Since Customer, Port, and Terminal are three kinds of different Locations, the base class Location is shared amongst them. Besides the general interface provided by Location, such as adding new segments to a Location, Customer, Port, and Terminal have their own notifiee interfaces. When one of these objects is destoyed, it notifies its notifiee (reactor) about its deletion. In our design, the reactor then updates the number of instances of this class in the ShippingNetwork. This is how we update the statistics.
 
3. Segment
    Besides keeping its own attributes, a Segment object is also used by Location to determine if its connecting segments follow the restrictions applied on the Location. For example, a Terminal object can only connect to Segments with the same transportation mode. In addition, similar to Location, Segment¡¦s reactors are used to update the statistics.

4. EngineManager
    EngineManager is the factory for instantiating the entities objects. Also, since all entities are instantiated from here, it notifies its reactor about the instantiation so that the reactor can update the statistics.

5.  ShippingNetwork
    ShippingNetwork records the system wide information, including statistics as well as the paths between different nodes under some restrictions, which matches to the Stats and Conn requirement.

6. Fleet, TruckFleet, PlaneFleet, and BoatFleet
    Since Fleet is used to store the system wide settings for 3 different kinds of transportation modes and should be a singleton, we use the subclasses of TruckFleet, PlaneFleet and BoatFleet which are all singletons for this purpose instead of using Segment::TransportationMode in a single Fleet  class to avoid the possible misunderstanding about whether the Fleet class is a singleton or not.

The Representation Layer
    The Representation Layer acts as an intermediate layer that interprets the message from the client as a series of actions performed on the Engine Layer and also translates the attributes in the Engine Layer into string format and passes them back to the client. Different requirements in the system have their corresponding classes in this layer, such as SegmentRep, ConnRep. Moreover, almost every Rep object has a corresponding Engine object to perform its logic operations. The only 2 exceptions are ConnRep and StatsRep, which utilize ShippingNetwork to get the information they need.
    Like the Engine Layer, the instances in the Representation Layer are managed by the manager, ManagerImp that is in charge of new/delete and indexing other Rep objects. The reason that every Rep classes are subclasses of Instance is because in that way their instances can be easily indexed and managed by ManagerImp.

Issues:
1. Dealing with Connectivity
    When deciding the data structure for storing and passing the path for exploring or connectivity in the Engine Layer, we discussed several options. The accessor for this path attribute could either return a path tree or a path of a given index. However, we considered the path tree a bad solution in that in the logical aspect it is actually returning a collection of paths. Instead, we believe a better solution is to call the path function with an index k as its parameter, and it returns a single path which is the k-th path in the path collection. In this case, the client code could manipulate these paths such as making comparisons (although not required in this assignment) without having to deal with the path tree by itself.

2. Using of smart pointer:
    While implementing the Notifier and Notifiee design, we discovered that we needed a pointer to the notifier in the notifiee, yet the pointer must not contribute to the reference count or else the notifier will never be deleted. To solve this, we created a WeakPtr class corresponding to the weak reference concept discussed in the textbook. Ideally WeakPtr should be a superclass of Ptr, but being unsure whether Ptr can be modified we simply kept them as two unrelated classes.
